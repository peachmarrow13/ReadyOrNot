#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PoseSearch

#include "Basic.hpp"

#include "PoseSearch_classes.hpp"
#include "PoseSearch_parameters.hpp"


namespace SDK
{

// Function PoseSearch.MotionMatchingAnimNodeLibrary.ConvertToMotionMatchingNode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAnimNodeReferenceConversionResult*     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMotionMatchingAnimNodeReference ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMotionMatchingAnimNodeReference UMotionMatchingAnimNodeLibrary::ConvertToMotionMatchingNode(const struct FAnimNodeReference& Node, EAnimNodeReferenceConversionResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "ConvertToMotionMatchingNode");

	Params::MotionMatchingAnimNodeLibrary_ConvertToMotionMatchingNode Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.ConvertToMotionMatchingNodePure
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FMotionMatchingAnimNodeReference*MotionMatchingNode                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::ConvertToMotionMatchingNodePure(const struct FAnimNodeReference& Node, struct FMotionMatchingAnimNodeReference* MotionMatchingNode, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "ConvertToMotionMatchingNodePure");

	Params::MotionMatchingAnimNodeLibrary_ConvertToMotionMatchingNodePure Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MotionMatchingNode != nullptr)
		*MotionMatchingNode = std::move(Parms.MotionMatchingNode);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.ForceInterruptNextUpdate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMotionMatchingAnimNodeReference&MotionMatchingNode                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::ForceInterruptNextUpdate(const struct FMotionMatchingAnimNodeReference& MotionMatchingNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "ForceInterruptNextUpdate");

	Params::MotionMatchingAnimNodeLibrary_ForceInterruptNextUpdate Parms{};

	Parms.MotionMatchingNode = std::move(MotionMatchingNode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.ResetDatabasesToSearch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMotionMatchingAnimNodeReference&MotionMatchingNode                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bForceInterrupt                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::ResetDatabasesToSearch(const struct FMotionMatchingAnimNodeReference& MotionMatchingNode, bool bForceInterrupt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "ResetDatabasesToSearch");

	Params::MotionMatchingAnimNodeLibrary_ResetDatabasesToSearch Parms{};

	Parms.MotionMatchingNode = std::move(MotionMatchingNode);
	Parms.bForceInterrupt = bForceInterrupt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.SetDatabasesToSearch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMotionMatchingAnimNodeReference&MotionMatchingNode                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<class UPoseSearchDatabase*>&Databases                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bForceInterruptIfNew                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::SetDatabasesToSearch(const struct FMotionMatchingAnimNodeReference& MotionMatchingNode, const TArray<class UPoseSearchDatabase*>& Databases, bool bForceInterruptIfNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "SetDatabasesToSearch");

	Params::MotionMatchingAnimNodeLibrary_SetDatabasesToSearch Parms{};

	Parms.MotionMatchingNode = std::move(MotionMatchingNode);
	Parms.Databases = std::move(Databases);
	Parms.bForceInterruptIfNew = bForceInterruptIfNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.SetDatabaseToSearch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMotionMatchingAnimNodeReference&MotionMatchingNode                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UPoseSearchDatabase*              Database                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceInterruptIfNew                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::SetDatabaseToSearch(const struct FMotionMatchingAnimNodeReference& MotionMatchingNode, class UPoseSearchDatabase* Database, bool bForceInterruptIfNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "SetDatabaseToSearch");

	Params::MotionMatchingAnimNodeLibrary_SetDatabaseToSearch Parms{};

	Parms.MotionMatchingNode = std::move(MotionMatchingNode);
	Parms.Database = Database;
	Parms.bForceInterruptIfNew = bForceInterruptIfNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PoseSearch.PoseSearchLibrary.MotionMatch
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPoseSearchDatabase*        Database                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPoseSearchQueryTrajectory&Trajectory                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// float                                   TrajectorySpeedMultiplier                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       PoseHistoryName                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset**                 SelectedAnimation                                      (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  SelectedTime                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bLoop                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bIsMirrored                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         BlendParameters                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  SearchCost                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAnimationAsset*            FutureAnimation                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FutureAnimationStartTime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeToFutureAnimationStart                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             DebugSessionUniqueIdentifier                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseSearchLibrary::MotionMatch(class UAnimInstance* AnimInstance, const class UPoseSearchDatabase* Database, const struct FPoseSearchQueryTrajectory& Trajectory, float TrajectorySpeedMultiplier, const class FName PoseHistoryName, class UAnimationAsset** SelectedAnimation, float* SelectedTime, bool* bLoop, bool* bIsMirrored, struct FVector* BlendParameters, float* SearchCost, const class UAnimationAsset* FutureAnimation, float FutureAnimationStartTime, float TimeToFutureAnimationStart, const int32 DebugSessionUniqueIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PoseSearchLibrary", "MotionMatch");

	Params::PoseSearchLibrary_MotionMatch Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.Database = Database;
	Parms.Trajectory = std::move(Trajectory);
	Parms.TrajectorySpeedMultiplier = TrajectorySpeedMultiplier;
	Parms.PoseHistoryName = PoseHistoryName;
	Parms.FutureAnimation = FutureAnimation;
	Parms.FutureAnimationStartTime = FutureAnimationStartTime;
	Parms.TimeToFutureAnimationStart = TimeToFutureAnimationStart;
	Parms.DebugSessionUniqueIdentifier = DebugSessionUniqueIdentifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SelectedAnimation != nullptr)
		*SelectedAnimation = Parms.SelectedAnimation;

	if (SelectedTime != nullptr)
		*SelectedTime = Parms.SelectedTime;

	if (bLoop != nullptr)
		*bLoop = Parms.bLoop;

	if (bIsMirrored != nullptr)
		*bIsMirrored = Parms.bIsMirrored;

	if (BlendParameters != nullptr)
		*BlendParameters = std::move(Parms.BlendParameters);

	if (SearchCost != nullptr)
		*SearchCost = Parms.SearchCost;
}

}

